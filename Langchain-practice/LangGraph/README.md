# LangGraph

## 탄생 배경

- RAG라는 강력한 기능을 갖게 되면서 아래의 갈등을 마주함.

1. LLM이 생성한 답변이 **Hallucination** 이 아닐까?
2. RAG를 적용해서 받은 답변이 문서에 없는 "**사전 지식**"으로 답변한 것은 아닌가?
3. "문서 검색에서 원하는 경우가 없을 경우" >> "인터넷" 혹은 "논문"에서 **부족한 정보를 검색**해서 지식을 보강할 수는 없을까?

## 고민 사례

- 일반 RAG를 수행했을 때 흔히 볼 수 있는 상황 (문서 내의 질문에 대한 답변이 존재하지 않는 경우)

- 부족한 정보를 Web 검색해서 문서에 추가하는 로직을 추가해보자!

- 만약, 검색결과에 잘못된 정보가 포함되거나 혹은 검색 결과가 없다면?

- 잘못된 검색결과가 결국 Hallucination으로 이어진다면?

- 결국, 코드가 점점 길어지고 복잡해진다. + LLM의 일관되지 않은 답변이 마치 나비효과로 이어져 답변의 품질 저하로 이어진다.

## Conventional RAG (= Naive RAG)의 문제점

- **사전에 정의**된 데이터 소싱 (PDF, DB, Table 등) 자원
- **사전에 정의**된 Fixed Size Chunk
- **사전에 정의**된 Query 입력
- **사전에 정의**된 검색 방법
- 신뢰하기 어려운 LLM 혹은 Agent
- **고정된** 프롬프트 형식
- LLM의 답변 결과에 대한 문서와의 관련성 / 신뢰성  
=> **단방향** 파이프라인

## LangGraph 제안

- 각 세부 과정을 **노드**(Node)라고 정의
- 이전 노드 >> 다음 노드 : **엣지**(Edge)연결
- **조건부 엣지**를 통해 분기 처리

## LangGraph

- Node, Edge, State를 통해 LLM을 활용한 워크플로우에 **순환 연산** 기능을 추가하여 손쉽게 흐름을 제어
    - Node : **함수**로 이루어져 있음.
- RAG 파이프라인의 세부 단계별 흐름 제어가 가능
- **Conditional Edge** : 조건부 흐름 제어
- **Human-in-the-loop** : 필요시 중간 개입하여 다음 단계를 결정
- **Checkpointer** : 과거 실행 과정에 대한 **수정**, **리플레이** 기능

---

# 세부 기능

## State (상태)

- 노드와 노드 간의 정보를 전달할 때 상태(State) 객체에 담아 전달
    - `TypedDict` : 일반 파이썬 dict에 **타입 힌팅**을 추가한 개념. dictionary로 생각해도 됨.
    - 모든 값을 다 채우지 않아도 된다.
    - 새로운 노드에서 값을 덮어쓰기 방식으로 채운다
    - Reducer(add_messages 혹은 operator.add) : 자동으로 list에 메시지를 추가해주는 기능

### TypedDict

- dict와 TypedDict의 차이점

    1. 타입 검사
        
        - `dict` : 런타임에 타입 검사를 하지 않음
        - `TypedDict` : **정적 타입 검사**를 제공함. 즉, 코드 작성 시 IDE나 타입 체커가 오류를 미리 잡아낼 수 있음. => 잠재적인 버그 미리 방지 가능

    2. 키와 값의 타입

        - `dict` : 키와 값의 타입을 일반적으로 지정
        - `TypedDict` : 각 키에 대해 구체적인 타입을 지정할 수 있음. => 딕셔너리 구조를 **명확하게 정의** 가능

    3. 유연성
    
        - `dict` : 런타임에 키를 추가하거나 제거할 수 있음.
        - `TypedDict` : 정의된 구조를 따라야 한다. 추가적인 키는 타입 오류를 발생시킨다.
    